use crate::state::{read_agents, read_chat_session, write_chat_session};
use candid::{CandidType, Principal};
use serde::{Deserialize, Serialize};

const LLM_CANISTER: &str = "w36hm-eqaaa-aaaal-qr76a-cai";
const TOOLS: &str = r#"
"#;

#[derive(CandidType, Serialize, Deserialize, Debug, Clone)]
pub enum Role {
    #[serde(rename = "system")]
    System,
    #[serde(rename = "user")]
    User,
    #[serde(rename = "assistant")]
    Assistant,
}

#[derive(CandidType, Serialize, Deserialize, Debug, Clone)]
pub struct ChatMessage {
    pub role: Role,
    pub content: String,
}

#[derive(CandidType, Deserialize)]
pub struct LlmRequest {
    pub model: String,
    pub messages: Vec<ChatMessage>,
}

pub struct Llm {
    pub principal: Principal,
}

impl Llm {
    pub async fn generate_secret_word(agent_name: &str, agent_description: &str) -> String {
        let system = format!(
            r#"You're an AI agent. Your name is {agent_name}. Here is some more description about you: {agent_description}. Your task is to generate some word for a lucky draw contest. If any user is able to guess the word, they win the prize.
    RULES for generating the word:
    1: number of words can range from 1 to 5. for e.g ("{agent_name}", "{agent_name} is awesome")
    2: generated word should be related to the agent's name, description.

    NOTE: return the secret word only.
"#
        );
        let llm_canister = Principal::from_text(LLM_CANISTER).unwrap();
        let contents = vec![
            ChatMessage {
                role: Role::System,
                content: system,
            },
            ChatMessage {
                role: Role::User,
                content: String::from("generate a word"),
            },
        ];
        let arg = LlmRequest {
            model: ic_llm::Model::Llama3_1_8B.to_string(),
            messages: contents,
        };
        ic_cdk::call::<(LlmRequest,), (String,)>(llm_canister, "v0_chat", (arg,))
            .await
            .unwrap()
            .0
    }

    /*

    pub struct AgentDetail {
        pub agent_id: u128,
        pub created_at: u64,
        pub created_by: Principal,
        pub allocated_raw_subaccount: [u8; 32],
        pub txns: (Option<String>, Option<String>),
        pub runeid: Option<String>,
        pub name: String,
        pub ticker: u32,
        pub description: String,
        pub logo: Option<String>,
        pub website: Option<String>,
        pub twitter: Option<String>,
        pub openchat: Option<String>,
        pub discord: Option<String>,
    }
        */
    pub async fn chat(
        session_id: u128,
        agent_id: u128,
        user_bitcoin_address: String,
        user_bitcoin_balance: u64,
        user_rune_balance: u128,
        message: String,
    ) -> String {
        let agent = read_agents(|agents| {
            let agent = agents.mapping.get(&agent_id).unwrap();
            agent
        });

        let mut token_info = String::new();
        token_info.push_str(&format!(
            "Token name: {}, Symbol: {},
        website: {:?}
        twitter: {:?}
        openchat: {:?}
        discord: {:?}",
            agent.name,
            char::from_u32(agent.ticker).unwrap(),
            agent.website,
            agent.twitter,
            agent.openchat,
            agent.discord
        ));
        token_info.push_str(&format!("Your agent id: {}", agent.agent_id));
        token_info.push_str(&format!(
            "Agent created at: {} UNIX time. created by {}",
            agent.created_at, agent.created_by
        ));
        token_info.push_str(&format!(
            "Here is the commit= {} and reveal {} transactions for token creation",
            agent.txns.0.unwrap(),
            agent.txns.1.unwrap()
        ));
        if let Some(runeid) = agent.runeid {
            token_info.push_str(&format!(
                "rune id: {}, which is equivalent to token's address/contract address",
                runeid
            ));
        }
        token_info.push_str(&format!(
            "Number of token holders: {}",
            agent.balances.len()
        ));

        token_info.push_str(&format!("Bait the bot competition where user will try to guess the word generated by AI. If they can guess the word they can will the prize pool. Current prize pool {} satoshis and {} {} tokens", agent.current_prize_pool.0, agent.current_prize_pool.1, agent.name));

        if let Some(winner) = agent.current_winner {
            token_info.push_str(&format!("Current prize is won by {}. Wait for the winner to claim the prize to start the next round", winner ));
        } else {
            token_info.push_str("Prize haven't been claimed so far.");
        }

        let system = format!(
            r#"You're a helpful AI agent. Your name is {}. Here is some more description about you: {}. The bitcoin wallet address of user is: {user_bitcoin_address}. User's bitcoin balance in satoshis: {user_bitcoin_balance} NOTE: 1 bitcoin = 100000000 sathises. user's rune token balance: {user_rune_balance} NOTE 1 token is = 1000 token. You're a tokenized agent. You should be able to reply questions asked about the token. You also have some small mini games. For now there is only one game, later on other games will be added too!. Token info: {}"#,
            agent.name, agent.description, token_info
        );
        let llm_canister = Principal::from_text(LLM_CANISTER).unwrap();
        let messages = read_chat_session(|sessions| {
            let session = sessions.session.get(&session_id).unwrap();
            let mut messages = vec![ChatMessage {
                role: Role::System,
                content: system,
            }];
            messages.extend_from_slice(&session.to_contents());
            messages
        });
        let arg = LlmRequest {
            model: ic_llm::Model::Llama3_1_8B.to_string(),
            messages,
        };
        let response = ic_cdk::call::<(LlmRequest,), (String,)>(llm_canister, "v0_chat", (arg,))
            .await
            .unwrap()
            .0;
        ic_cdk::println!("Response from calling the agent: {:?}", response);
        write_chat_session(|sessions| {
            let mut session = sessions.session.get(&session_id).unwrap();
            session.record_content(vec![
                ChatMessage {
                    role: Role::User,
                    content: message,
                },
                ChatMessage {
                    role: Role::Assistant,
                    content: response.clone(),
                },
            ]);
            session.last_interacted = ic_cdk::api::time();
            sessions.session.insert(session_id, session);
        });
        response
    }
}
